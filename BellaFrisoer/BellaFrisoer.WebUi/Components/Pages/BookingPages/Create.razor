@* 
  Create.razor
  Purpose: Blazor page to create a new Booking.
  The comments explain each directive, markup block and code member.
*@

@* Route for the page: component is accessible at /bookings/create *@
@page "/bookings/create"

@* Bring EF Core asynchronous query extensions (ToListAsync, OrderBy, Include) into scope *@
@using Microsoft.EntityFrameworkCore
@using System.Globalization

@* Provide Blazor form components like EditForm, InputText, InputSelect, ValidationMessage *@
@using Microsoft.AspNetCore.Components.Forms

@* Domain model types used on this page: Booking, Customer, Employee *@
@using BellaFrisoer.Domain.Models

@using BellaFrisoer.Application.Interfaces
@inject IBookingConflictChecker BookingConflictChecker

@* Inject a factory for creating short-lived DbContext instances in Blazor Server safely *@
@inject IDbContextFactory<BellaFrisoer.Infrastructure.Data.BellaFrisoerWebUiContext> DbFactory

@* Inject NavigationManager to perform client navigation after saves *@
@inject NavigationManager NavigationManager



@* Render mode for Blazor Server with interactive prerendering (keeps component interactive) *@
@rendermode InteractiveServer

@* Sets the browser title while this page is active *@
<PageTitle>Opret Booking</PageTitle>

@* Page heading shown to users *@
<h1>Opret Booking</h1>

@* Show a persistent error area when ErrorMessage is set in the component state *@
@if (!string.IsNullOrEmpty(ErrorMessage))
{
    <div class="alert alert-danger" role="alert">@ErrorMessage</div>
}

@* Show a loading indicator while we fetch customers (customers is null until loaded) *@
@if (customers == null)
{
    <p><em>Loading...</em></p>
}
else
{
    @* Main form binding to the Booking instance.
       - Model: the object bound to inputs and validated by DataAnnotations
       - OnValidSubmit: handler when validation passes
       - OnInvalidSubmit: handler when validation fails *@
    <EditForm Model="Booking" OnValidSubmit="AddBooking" OnInvalidSubmit="OnInvalidSubmit" FormName="BookingForm">
        @* Enables data-annotation validation on the model *@
        <DataAnnotationsValidator />
        @* Displays a summary of validation errors *@
        <ValidationSummary />

        <div class="mb-3">
            <label class="form-label">Booking Dato</label>
            <InputDate @bind-Value="Booking.BookingDate" class="form-control" />
            <ValidationMessage For="@(() => Booking.BookingDate)" />
        </div>

        <div class="mb-3">
            <label class="form-label">Booking starttidspunkt</label>
            <InputText type="time" @bind-Value="BookingStartTimeString" class="form-control" />
            <ValidationMessage For="@(() => Booking.BookingStartTime)" />
        </div>

        <div class="mb-3">
            <label class="form-label">Booking varighed</label>
            <InputText type="time" @bind-Value="BookingEndTimeString" class="form-control" />
            <ValidationMessage For="@(() => Booking.BookingDuration)" />
        </div>

        <div class="mb-3">
	        <label class="form-label">Kunde</label>
	        @if (!customers.Any())
	        {
		        <div>
			        <p>Ingen kunder endnu... <a href="/customers/create">Opret Kunde</a></p>
		        </div>
	        }
	        else
	        {
		        <InputSelect @bind-Value="Booking.CustomerId" class="form-select">
			        <option value="0">-- Vælg Kunde --</option>
			        @foreach (var c in customers)
			        {
				        <option value="@c.Id">@c.Name (@(c.PhoneNumber?.ToString() ?? "Intet tlf nummer..."))</option>
			        }
		        </InputSelect>
		        <ValidationMessage For="@(() => Booking.CustomerId)" />
	        }
        </div>

        <div class="mb-3">
	        <label class="form-label">Ansatte</label>
	        @if (employees == null || !employees.Any())
	        {
		        <div>
			        <p>Ingen registrerede ansatte... <a href="/customers/create">Opret Ansat</a></p>
		        </div>
	        }
	        else
	        {
		        <InputSelect @bind-Value="Booking.EmployeeId" class="form-select">
			        <option value="0"> -- Vælg Ansat --</option>
			        @foreach (var e in employees)
			        {
				        <option value="@e.Id">@e.Name (@(e.PhoneNumber?.ToString() ?? "Intet tlf nummer..."))</option>
			        }
		        </InputSelect>
		        <ValidationMessage For="@(() => Booking.EmployeeId)" />
	        }
        </div>

        <button class="btn btn-primary" type="submit" disabled="@(!customers.Any())">Create</button>
        <a class="btn btn-link" href="/customers/create">Create customer</a>
    </EditForm>
}

@code {
    private Booking Booking { get; set; } = new Booking { BookingDate = DateTime.Now, CustomerId = 0 };

    private List<Customer>? customers;
    private List<Employee> employees = new();
    private string? ErrorMessage;

    private string BookingStartTimeString
    {
        get
        {
            var dt = Booking.BookingStartTime == default ? Booking.BookingDate : Booking.BookingStartTime;
            return dt.ToString("HH:mm", CultureInfo.InvariantCulture);
        }
        set
        {
            // robust parsing: prefer TimeOnly (HH:mm from browser), fallback to TimeSpan
            if (TimeOnly.TryParseExact(value, "HH:mm", CultureInfo.InvariantCulture, DateTimeStyles.None, out var t))
            {
                Booking.BookingStartTime = Booking.CombineDateTime(Booking.BookingDate.Date, t.ToTimeSpan());
            }
            else if (TimeSpan.TryParseExact(value, new[] { "h\\:mm", "hh\\:mm", "hh\\:mm\\:ss" }, CultureInfo.InvariantCulture, out var ts))
            {
                Booking.BookingStartTime = Booking.CombineDateTime(Booking.BookingDate.Date, ts);
            }
            // else ignore invalid input (UI validation should prevent this); you may set ErrorMessage if needed
        }
    }

    private string BookingEndTimeString
    {
        get
        {
            // Prefer explicit duration if set; otherwise compute from start/end
            var duration = Booking.BookingDuration;
            if (duration == default && Booking.BookingEndTime != default && Booking.BookingStartTime != default)
            {
                duration = Booking.BookingEndTime - Booking.BookingStartTime;
            }

            return duration.ToString(@"hh\:mm", CultureInfo.InvariantCulture);
        }
        set
        {
            // user enters HH:mm representing a duration (hours:minutes)
            if (TimeSpan.TryParseExact(value, new[] { "h\\:mm", "hh\\:mm", "hh\\:mm\\:ss" }, CultureInfo.InvariantCulture, out var ts))
            {
                Booking.BookingDuration = ts;
            }
            else if (TimeSpan.TryParse(value, CultureInfo.InvariantCulture, out ts))
            {
                Booking.BookingDuration = ts;
            }
            // No else: keep previous duration if parsing fails
        }
    }

    protected override async Task OnInitializedAsync()
    {
        using var ctx = DbFactory.CreateDbContext();
        customers = await ctx.Customers.OrderBy(c => c.Name).ToListAsync();
        employees = await ctx.Employees.OrderBy(e => e.Name).ToListAsync();
    }

    private void OnInvalidSubmit(EditContext ctx)
    {
        ErrorMessage = "Form is invalid. Please fix validation errors.";
    }

    private async Task AddBooking()
    {
        ErrorMessage = null;

        if (Booking.CustomerId <= 0)
        {
            ErrorMessage = "Vælg kunde...";
            return;
        }

        if (Booking.EmployeeId <= 0)
        {
            ErrorMessage = "Vælg ansat...";
            return;
        }

        if (Booking.BookingStartTime == default)
        {
            ErrorMessage = "Ugyldigt starttidspunkt.";
            return;
        }
        if (Booking.BookingDuration == default || Booking.BookingDuration.TotalMinutes <= 0)
        {
            ErrorMessage = "Ugyldig varighed.";
            return;
        }

        // Fetch potentially conflicting bookings from the database for the same day
        using (var ctx = DbFactory.CreateDbContext())
        {
            var existingBookings = await ctx.Bookings
                .Where(b => b.EmployeeId == Booking.EmployeeId)
                .ToListAsync();

            if (BookingConflictChecker.HasBookingConflict(Booking, existingBookings))
            {
                ErrorMessage = "Booking conflict: selected customer or employee already has a booking during this time.";
                return;
            }
        }

        try
        {
            using var ctx = DbFactory.CreateDbContext();
            ctx.Bookings.Add(Booking);
            await ctx.SaveChangesAsync();
            NavigationManager.NavigateTo("/bookings");
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Save failed: {ex.Message}";
        }
    }
}
